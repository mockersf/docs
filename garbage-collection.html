<!DOCTYPE html>
<html>
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-60508041-1"></script>

<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-60508041-1');
</script>

<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=775" />
<title>Garbage Collection - Concourse CI</title>
<link rel="stylesheet" type="text/css" href="css/normalize.css" />
<link rel="stylesheet" type="text/css" href="css/pipeline.css" />
<link rel="stylesheet" type="text/css" href="css/iosevka.css" />
<link rel="stylesheet" type="text/css" href="css/booklit.css" />
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
<link href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700|Roboto+Slab:300,400,700" rel="stylesheet" />
<script src="js/search.js"></script>
  </head>
  <body>
    <div class="top-logo">
  <a href="/">Concourse</a>
</div>

<nav class="top-nav">
  
  <a href="docs.html">Docs</a>
  
  <a href="download.html">Download</a>
  
  <a href="project.html" class="active">Project</a>
  
  <a href="community.html">Community</a>
  
  <a href="learning.html">Learning</a>
  
</nav>

<div class="top-search">
  <div id="search"></div>
</div>

<script type="text/javascript">
  Elm.Main.init({
    node: document.getElementById('search')
  });
</script>

    <div class="page-nav">
      







  
  
  
  
  

  
  <div class="context">
    <nav>
      <div class="top">
        
        <span class="section-number">3</span>
        
        
  <a href="project.html"  class="active">Project</a>

      </div>

      <div class="children">
        <table>
        
          <tr>
            
              <td class="number-cell" align="right">3.1&nbsp;</td>
            
            <td class="title-cell">
  <a href="contribute.html" >Contribute</a>
</td>
          </tr>
        
          <tr>
            
              <td class="number-cell" align="right">3.2&nbsp;</td>
            
            <td class="title-cell">
  <a href="architecture.html"  class="active">Architecture</a>
</td>
          </tr>
        
          <tr>
            
              <td class="number-cell" align="right">3.3&nbsp;</td>
            
            <td class="title-cell">
  <a href="thanks.html" >Thanks!</a>
</td>
          </tr>
        
          <tr>
            
              <td class="number-cell" align="right">3.4&nbsp;</td>
            
            <td class="title-cell">
  <a href="trademarks.html" >Trademarks</a>
</td>
          </tr>
        
        </table>
      </div>
    </nav>
  </div>
  

  

  
  <div class="context">
    <nav>
      <div class="top">
        
        <span class="section-number">3.2</span>
        
        
  <a href="architecture.html"  class="active">Architecture</a>

      </div>

      <div class="children">
        <table>
        
          <tr>
            
              <td class="number-cell" align="left"></td>
            
            <td class="title-cell">
  <a href="architecture.html#component-atc" >ATC: web UI &amp; build scheduler</a>
</td>
          </tr>
        
          <tr>
            
              <td class="number-cell" align="left"></td>
            
            <td class="title-cell">
  <a href="architecture.html#component-tsa" >TSA: worker registration &amp; forwarding</a>
</td>
          </tr>
        
          <tr>
            
              <td class="number-cell" align="left"></td>
            
            <td class="title-cell">
  <a href="architecture.html#architecture-worker" >Workers: container runtime &amp; cache management</a>
</td>
          </tr>
        
          <tr>
            
              <td class="number-cell" align="left"></td>
            
            <td class="title-cell">
  <a href="architecture.html#internals"  class="active">Internals</a>
</td>
          </tr>
        
        </table>
      </div>
    </nav>
  </div>
  

  

  
  <div class="context">
    <nav>
      <div class="top">
        
        
  <a href="architecture.html#internals"  class="active">Internals</a>

      </div>

      <div class="children">
        <table>
        
          <tr>
            
              <td class="number-cell" align="right">3.2.4.1&nbsp;</td>
            
            <td class="title-cell">
  <a href="database-schema.html" >Database Schema</a>
</td>
          </tr>
        
          <tr>
            
              <td class="number-cell" align="right">3.2.4.2&nbsp;</td>
            
            <td class="title-cell">
  <a href="garbage-collection.html"  class="self">Garbage Collection</a>
</td>
          </tr>
        
          <tr>
            
              <td class="number-cell" align="right">3.2.4.3&nbsp;</td>
            
            <td class="title-cell">
  <a href="volume-internals.html" >Volumes</a>
</td>
          </tr>
        
          <tr>
            
              <td class="number-cell" align="right">3.2.4.4&nbsp;</td>
            
            <td class="title-cell">
  <a href="container-internals.html" >Containers</a>
</td>
          </tr>
        
          <tr>
            
              <td class="number-cell" align="right">3.2.4.5&nbsp;</td>
            
            <td class="title-cell">
  <a href="worker-internals.html" >Workers</a>
</td>
          </tr>
        
          <tr>
            
              <td class="number-cell" align="right">3.2.4.6&nbsp;</td>
            
            <td class="title-cell">
  <a href="caching-and-retention.html" >Caching &amp; Retention</a>
</td>
          </tr>
        
        </table>
      </div>
    </nav>
  </div>
  





<div class="context">
  <div class="page-toc">
    <nav>
      <div class="top">
        
        <span class="section-number">3.2.4.2</span>
        
        
  <a href="garbage-collection.html"  class="self">Garbage Collection</a>

      </div>

      
<div class="children">
  <table>
    
      <tr>
        
          <td class="number-cell" align="left"></td>
        
        <td class="title-cell">
          <a href="garbage-collection.html#goals">Goals</a>

          
        </td>
      </tr>
    
      <tr>
        
          <td class="number-cell" align="left"></td>
        
        <td class="title-cell">
          <a href="garbage-collection.html#how-it-works">How it Works</a>

          
<div class="children">
  <table>
    
      <tr>
        
          <td class="number-cell" align="left"></td>
        
        <td class="title-cell">
          <a href="garbage-collection.html#container-collection">Container Collection</a>

          
        </td>
      </tr>
    
      <tr>
        
          <td class="number-cell" align="left"></td>
        
        <td class="title-cell">
          <a href="garbage-collection.html#volume-collection">Volume Collection</a>

          
        </td>
      </tr>
    
  </table>
</div>

        </td>
      </tr>
    
  </table>
</div>

    </nav>
  </div>
</div>




    </div>

    <div class="page-aside"></div>

    <div class="page-content">
      <div class="section" id="section_garbage-collection">
  
  <h1 class="section-header"><a class="anchor" name="garbage-collection" href="#garbage-collection"></a><span class="section-number">3.2.4.2 </span>Garbage Collection</h1>
  

  <p>One key difference between Concourse and other CI systems is that everything runs in isolated environments. Where some CI systems may just run builds one at a time on a single VM and reusing a working directory, Concourse creates fresh <a href="container-internals.html">Containers</a> and <a href="volume-internals.html">Volumes</a> to ensure things can safely run in a repeatable environment, isolated from other workloads running on the same worker.</p><p>This introduces a new problem of knowing when Concourse should remove these containers and volumes. Safely identifying things for removal and then getting rid of them, releasing their resources, is the process of <em>garbage collection</em>.</p>

  
    
      <div class="section" id="section_goals">
  
  <h2 class="section-header"><a class="anchor" name="goals" href="#goals"></a>Goals</h2>
  

  <p>Let&#39;s define our metrics for success:</p><ul>

  <li><p><strong>Safe</strong>. There should never be a case where a build is running and a container or volume is removed out from under it, causing the build to fail. Resource checking should also never result in errors from check containers being removed. No one should even know garbage collection is happening.</p></li>

  <li><p><strong>Airtight</strong>. Everything Concourse creates, whether it&#39;s a <a href="container-internals.html">container</a> or <a href="volume-internals.html">volume</a> on a worker or an entry in the database, should never leak. Each object should have a fully defined lifecycle such that there is a clear end to its use.  The ATC should be interruptible at any point in time and at the very least be able to remove any state it had created beforehand.</p></li>

  <li><p><strong>Resilient</strong>. Garbage collection should never be outpaced by the workload. A single misbehaving worker should not prevent garbage collection from being performed on other workers. A slow delete of a volume should not prevent garbage collecting of other things on the same worker.</p></li>

</ul>

  
    
  
</div>
    
      <div class="section" id="section_how-it-works">
  
  <h2 class="section-header"><a class="anchor" name="how-it-works" href="#how-it-works"></a>How it Works</h2>
  

  <p>The garbage collector is a batch operation that runs every 30 seconds. This number was chosen arbitrarily and may be reduced in the future. It&#39;s important to note that the collector must be able to run frequently enough to not be outpaced by the workload producing things, and so the batch operation should be able to complete pretty quickly.</p><p>The batch operation first performs garbage collection within the database alone, removing rows that are no longer needed. The removal of rows from one stage will often result in removals in a later stage.  They are run in the following order:</p><ul>

  <li><p><a href="database-schema.html#builds-table"><code><strong>builds</strong></code></a> that no longer meet the <a href="caching-and-retention.html#build-retention">Build Retention</a> criteria are marked non-interceptible</p></li>

  <li><p><a href="database-schema.html#workers-table"><code><strong>workers</strong></code></a> are stepped through their state machine. Unresponsive workers become <code>STALLED</code>, workers that are <code>RETIRING</code> are deleted once drained, and workers that are <code>LANDING</code> become <code>LANDED</code> once drained.</p></li>

  <li><p><a href="database-schema.html#build_image_resource_caches-table"><code><strong>build_image_resource_caches</strong></code></a> are removed for builds that finished over 24 hours ago.</p></li>

  <li><p><a href="database-schema.html#resource_cache_uses-table"><code><strong>resource_cache_uses</strong></code></a> are removed for builds that are no longer interceptible.</p></li>

  <li><p><a href="database-schema.html#resource_configs-table"><code><strong>resource_configs</strong></code></a> that are no longer referenced by a <a href="database-schema.html#resource_caches-table"><code><strong>resource_caches</strong> (resource_config_id)</code></a> or a <a href="database-schema.html#resource_config_check_sessions-table"><code><strong>resource_config_check_sessions</strong> (resource_config_id)</code></a> are removed.</p></li>

  <li><p><a href="database-schema.html#resource_caches-table"><code><strong>resource_caches</strong></code></a> that are no longer referenced by a <a href="database-schema.html#resource_configs-table"><code><strong>resource_configs</strong> (resource_cache_id)</code></a> or a <a href="database-schema.html#resource_cache_uses-table"><code><strong>resource_cache_uses</strong> (resource_cache_id)</code></a> are removed.</p></li>

  <li><p><a href="database-schema.html#resource_config_check_sessions-table"><code><strong>resource_config_check_sessions</strong></code></a> that have exceeded their <a href="database-schema.html#resource_config_check_sessions-table"><code><strong>resource_config_check_sessions</strong> (expires_at)</code></a> are removed.</p></li>

</ul><p>If any of the above operations fail, the garbage collector will just log an error and move on. This is so that failure to collect one class of objects does not prevent everything else from being garbage collected. Failure at any part of the garbage collection is OK; it can just retry on the next pass.</p><p>After the initial pass of garbage collection in the database, there should now be a set of <a href="database-schema.html#volumes-table"><code><strong>volumes</strong></code></a> and <a href="database-schema.html#containers-table"><code><strong>containers</strong></code></a> that meet criteria for garbage collection. These two are a bit more complicated to garbage-collect; they both require talking to a worker, and waiting on a potentially slow delete.</p><p>Containers and volumes are the costliest resources consumed by Concourse. There are also many of them created over time as builds execute and pipelines perform their <a href="pipelines.html#pipeline-resources">resource checking</a>. Therefore it is important to parallelize this aspect of garbage collection so that one slow delete or one slow worker does not cause them to pile up.</p><p>So, the next two steps are <a href="garbage-collection.html#container-collection">Container Collection</a> and <a href="garbage-collection.html#volume-collection">Volume Collection</a>.</p>

  
    
      <div class="section" id="section_container-collection">
  
  <h3 class="section-header"><a class="anchor" name="container-collection" href="#container-collection"></a>Container Collection</h3>
  

  <p>First, a fairly simple query is executed to find containers that meet one of the following conditions:</p><ul>

  <li><p>If it has a <code>NULL</code> reference for all four dependent columns:</p><ul>

  <li><p><a href="database-schema.html#containers-table"><code><strong>containers</strong> (build_id)</code></a></p></li>

  <li><p><a href="database-schema.html#containers-table"><code><strong>containers</strong> (image_check_container_id)</code></a></p></li>

  <li><p><a href="database-schema.html#containers-table"><code><strong>containers</strong> (image_get_container_id)</code></a></p></li>

  <li><p><a href="database-schema.html#containers-table"><code><strong>containers</strong> (worker_resource_config_check_session_id)</code></a></p></li>

</ul><p>This is the simplest case: the things that needed the container are now gone, so it can go away.</p></li>

  <li><p>The <a href="database-schema.html#containers-table"><code><strong>containers</strong> (build_id)</code></a> referenced by the container is no longer interceptible. See <a href="caching-and-retention.html#build-retention">Build Retention</a>.</p></li>

  <li><p>The <a href="database-schema.html#containers-table"><code><strong>containers</strong> (image_check_container_id)</code></a> or <a href="database-schema.html#containers-table"><code><strong>containers</strong> (image_get_container_id)</code></a> referenced by the container is no longer in <code>CREATING</code> state (likely <code>CREATED</code>).</p></li>

</ul><p>Once these containers are found, they are all deleted in parallel, with a max-in-flight limit per worker so that the worker doesn&#39;t get hammered by a burst of writes.</p><p>The deletion of every container is a careful process to ensure they never leak and are never deleted while a user is hijacked into them:</p><ul>

  <li><p>If the container is <code>CREATING</code>, we mark it <code>CREATED</code>. This is a bit wonky but makes it easier to just step it through the rest of the lifecycle, since if there was a container being created on the worker, we need to clean it up.</p></li>

  <li><p>If the container is <code>CREATED</code>, we first check to see if it was hijacked. If not, we transition it to <code>DESTROYING</code>.</p><p>If the container is hijacked, we try to find the container in the worker.</p><p>If the worker container is found, we set a <em>grace time</em> on it (a period of inactivity after which the container will be reaped by the worker itself), mark the database container as <em>discontinued</em>, and transition the container to <code>DESTROYING</code>.</p><p>If the worker container is not found, we transition the container to <code>DESTROYING</code>, just to funnel it down the same code path as below.</p></li>

  <li><p>If the container is <code>DESTROYING</code>, and the container is <em>discontinued</em>, we check if the container has expired yet (via the grace time) by looking for it on the worker. If it&#39;s still there, we leave it alone, and leave the container in the database. If it&#39;s gone, we reap the container from the database.</p><p>If the container is not discontinued, we destroy the container on the worker and reap the container from the database.</p></li>

</ul><p>Note that if any point of the above process <em>fails</em>, the container is left in its current state in the database. A container is only ever removed from the database when it&#39;s guaranteed that everything has been cleaned up.</p>

  
    
  
</div>
    
      <div class="section" id="section_volume-collection">
  
  <h3 class="section-header"><a class="anchor" name="volume-collection" href="#volume-collection"></a>Volume Collection</h3>
  

  <p>Volume collection is quite a bit simpler than <a href="garbage-collection.html#container-collection">Container Collection</a>.</p><p>First, volumes are found for deletion. This is just a query for volumes that have <code>NULL</code> references for all four volume owners:</p><ul>

  <li><p><a href="database-schema.html#volumes-table"><code><strong>volumes</strong> (worker_resource_cache_id)</code></a></p></li>

  <li><p><a href="database-schema.html#volumes-table"><code><strong>volumes</strong> (worker_base_resource_type_id)</code></a></p></li>

  <li><p><a href="database-schema.html#volumes-table"><code><strong>volumes</strong> (worker_resource_cache_id)</code></a></p></li>

  <li><p><a href="database-schema.html#volumes-table"><code><strong>volumes</strong> (worker_resource_cache_id)</code></a></p></li>

</ul><p>Next, each <code>CREATED</code> volume is transitioned to <code>DESTROYING</code>. This transition can fail if the volume is being used as the parent of a copy-on-write volume that is still in use (e.g. by a build).</p><p>Then, for each volume for <code>DESTROYING</code> state, including those that were just transitioned, we execute the following in parallel (as with containers, there is a max-in-flight limit per worker):</p><ul>

  <li><p>First, look up the volume on the worker and destroy it if it&#39;s found.</p></li>

  <li><p>Next, delete the volume from the database.</p></li>

</ul><p>As with containers, if any part of the deletion sequence returns an error, the volume is skipped. A volume is only ever removed from the database when it&#39;s guaranteed that everything has been cleaned up.</p>

  
    
  
</div>
    
  
</div>
    
  
</div>

      <nav class="prev-next">
      
        <div class="prev">
          prev:

          
          <span class="section-number">3.2.4.1</span>
          

          <a href="database-schema.html">Database Schema</a>
        </div>
      

      
        <div class="next">
          next:

          
          <span class="section-number">3.2.4.3</span>
          

          <a href="volume-internals.html">Volumes</a>
        </div>
      
      </nav>
    </div>

    <ul class="improve-docs">
      <li><img src="images/github.svg" /> <a href="https://github.com/concourse/docs">help improve this site</a></li>
      <li><img src="images/booklit.svg" /> powered by <a href="https://vito.github.io/booklit">Booklit</a></li>
    </ul>
  </body>
</html>